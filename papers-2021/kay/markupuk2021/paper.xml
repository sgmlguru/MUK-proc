<?xml version="1.0" encoding="utf-8"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0"
  xml:lang="en">
  <info>
    <title><![CDATA[<transpile from="Java" to="C#" via="XML" with="XSLT"/>]]></title>
 

    <author>
      <personname>Michael Kay</personname>
      <email>mike@saxonica.com</email>
      <uri>http://www.saxonica.com/</uri>
      <personblurb>
        <para>Michael Kay is the founder and technical lead designer at Saxonica,
        which was set up in 2004 to develop the Saxon XSLT and XQuery processor.
        He was the editor of the XSLT 2.0 and 3.0 specifications at W3C.</para>
      </personblurb>
      <affiliation>
        <orgname>Saxonica</orgname>
      </affiliation>
    </author>



    <abstract>
      <para>This paper describes a project in which XSLT 3.0 was used to convert a substantial body of Java
    code (around 500K lines of code) to C#. The Java code, as it happens, is the source code of the 
    Saxon XSLT processor, but that's not really relevant: it could have been anything. 
  </para>

    </abstract>
  </info>

  

  <section>
    <title>Introduction</title>

    <para>For a number of years, Saxonica has developed the Saxon product
      <footnote><para><uri xl:href="http://www.saxonica.com/">http://www.saxonica.com/</uri></para></footnote>, 
      a Java implementation of the W3C XSLT, 
      XQuery, XPath, and XSD specifications. The product has also been made available on the 
      .NET platform, by converting the bytecode generated by the Java compiler into the equivalent 
      intermediate language (called IL) on .NET. The tool for this conversion was the open-source 
      IKVMC library<footnote><para><uri xl:href="http://www.ikvm.net/">http://www.ikvm.net/</uri></para></footnote> developed by Jeroen Frijters.
    </para>
    <para>IKVMC was largely a one-man project, and when Jeroen (after many years of faithful 
      service to the community) decided to move on to other things, there was no-one to step 
      into his capable shoes, and the project has languished.
    </para>
    <para>In 2019, Microsoft announced a change of direction for the .NET 
      platform<footnote><para><uri xl:href="https://devblogs.microsoft.com/dotnet/net-core-is-the-future-of-net/">https://devblogs.microsoft.com/dotnet/net-core-is-the-future-of-net/</uri></para></footnote>. .NET had 
      diverged into two separate strands of development, known as .NET Framework and .NET Core, 
      and Microsoft announced in effect that .NET Framework would be discontinued, and the 
      future lay with .NET Core. The differences between the two strands need not really concern 
      us here, except to note that IKVMC never supported .NET Core, therefore Saxon didn't run on 
      .NET Core, and therefore we needed to find a different way forward.
    </para>
    <para>The way that we chose was source code conversion from Java to C#. At the time of writing 
      this has been successfully achieved for a large subset of the Saxon product, and work is 
      ongoing to convert the remainder. This paper describes how it was done.
    </para>
    <para>Let's start by describing the objectives of the project:
</para>
    <itemizedlist>
      <listitem>
        <para>Automated conversion of as much of the source code as possible from Java to C#.</para>
      </listitem>
      <listitem>
        <para>Repeatable conversion: this is not a one-off conversion to create a fork of the code; 
          we want to continue developing and maintaining the master Java code and port all changes 
          over to C# using the same conversion technology.
</para>
      </listitem>
      <listitem>
        <para>Performance: the performance of the final product on .NET must be at least as good 
          as the existing product. In fact, we would like it to be considerably better, because 
          (for reasons we have never fully understood) some workloads on the current product 
          perform much more slowly than on the Java platform.
</para>
      </listitem>
      <listitem>
        <para>Maintainability: although we don't intend to develop the C# code independently, 
          we will certainly need to debug it, and that means we need to generate human-readable code.
</para>
      </listitem>
      <listitem>
        <para>Adaptability: because the .NET platform is different from the Java platform, 
          some parts of the product need to behave differently. We need to have convenient 
          mechanisms to manage these differences.
</para>
      </listitem>
    </itemizedlist>
    <para>I should also stress one non-objective: we were not setting out to provide a tool that 
      could convert any Java program to C# fully automatically. We only needed to convert one (admittedly 
      rather large) program, and this meant that:
</para>
    <orderedlist>
      <listitem>
        <para>We only needed to convert Java constructs that Saxon actually uses (which turns out to be quite 
          a small subset of the total Java platform).
      </para>
      </listitem>
      <listitem>
        <para>In the case of constructs that Saxon uses rarely, we could do some manual assistance of 
          the conversion, rather than requiring it fully automatic. Indeed, by Zipf's law, many of the 
          Java constructs that Saxon uses are only used once in the entire product, and in many cases 
          they are used unnecessarily and could easily be rewritten a different way (sometimes beneficially). 
          The main device we have used for this manual assistance is the use of Java annotations in the 
          source code, annotations that are specially recognised as hints by the converter.
      </para>
      </listitem>
    </orderedlist>
  </section>
  <section>
    <title>Preliminaries</title>

    <para>Our initial investigations explored a number of available tools for source code conversion. 
      The only one that looked at all promising was a commercial product, 
      Tangible<footnote><para><uri xl:href="https://www.tangiblesoftwaresolutions.com">https://www.tangiblesoftwaresolutions.com</uri></para></footnote>. We bought a license 
      to evaluate its capabilities, and the exercise taught us a lot about where the difficulties were 
      going to arise. It was immediately apparent that we would have considerable difficulties with Java 
      generics, with anonymous inner classes, and with our extensive use of the Java <code>CharSequence</code> interface, 
      which has no direct equivalent in .NET. The exercise also taught us that Tangible, on its own, wasn't 
      up to the job. (Having said that, the conversions performed by Tangible helped us greatly in defining 
      our own rules.)
</para>
    <para>Our next step was to reduce our dependence on the constructs that were going to prove difficult 
      to convert: especially generics, and the use of <code>CharSequence</code>. I have described in more detail how we 
      achieved this in blog postings: <footnote><para><uri xl:href="https://dev.saxonica.com/blog/mike/2020/07/string-charsequence-ikvm-and-net.html">https://dev.saxonica.com/blog/mike/2020/07/string-charsequence-ikvm-and-net.html</uri></para></footnote>
      <footnote><para><uri xl:href="https://dev.saxonica.com/blog/mike/2020/01/java-generics-revisited.html">https://dev.saxonica.com/blog/mike/2020/01/java-generics-revisited.html</uri></para></footnote>.
</para>
    <para>Generics are difficult because although Java and C# use superficially-similar syntax (for example 
      <code>List&lt;String></code>) the semantics are very different. 
  In C# instances are annotated at run-time with the full expanded type, and one can therefore write 
  run-time tests such as x is <code>List&lt;String></code>. Writing <code>x is List</code> will return false: <code>List&lt;String></code> 
  is not a subtype of <code>List</code>. By contrast, with Java, the type parameters are used only at compile time 
  and are discarded at run time (the process is called <emphasis>Type Erasure</emphasis>). This means that on Java, 
  <code>x instanceof List&lt;String></code> is not allowed, while <code>x instanceof List</code> returns true.
</para>
    <para>We decided to reduce the scale of the problem by dropping some of our use of generics 
      from the product. In particular, in Saxon 9.9, two key interfaces, <code>Sequence</code> and <code>SequenceIterator</code>, 
      were defined with type parameters restricting the type of items contained in an XDM sequence, 
      and we dropped this in Saxon 10.0. The use of type parameters here had always been somewhat 
      unsatisfactory, for two reasons:
</para>
    <para>Most of the time, the code has to deal with sequences-of-anything: we don't know statically, 
      when we write the Saxon code, what type of input it is going to be dealing with (that depends on 
      the user-written stylesheet). So providing the type parameter (<code>Sequence&lt;Item></code>) simply doesn't 
      add any value.
</para>
    <para>The XDM model for sequences has the property that an item is a sequence of length one. So 
      <code>Item</code> implements <code>Sequence&lt;Item></code>. Which means that a subclass of <code>Item</code>, such as <code>DateTimeValue</code>, 
      implements <code>Sequence&lt;DateTimeValue></code>. Which followed to its logical conclusion mans that a 
      <code>DateTimeValue</code> is an <code>Item&lt;DateTimeValue></code>, and a generic item is therefore an <code>Item&lt;Item></code> 
      (or is it an <code>Item&lt;Item&lt;Item&lt;...>>></code>?). Modelling the XDM structure accurately using 
      Java generics proved very difficult, and in the end, it introduced a whole load of complexity 
      without adding much value. Getting rid of it was welcome.
</para>
    <para>As far as the <code>CharSequence</code> interface is concerned, we used this extensively in interfaces 
      where strings are passed around, to enable us to use implementations of strings other than the 
      Java <code>String</code> class. For example, the whitespace that often occurs between elements in an XML document 
      is compressed using run-length encoding as a <code>CompressedWhitespace</code> object, which implements the 
      <code>CharSequence</code> interface, and can therefore be substituted in many cases for a Java <code>String</code>.
</para>
    <para>The use of <code>CharSequence</code> isn't perfect for this purpose, however. Firstly, it has the same problem 
      as a Java <code>String</code> in that it models a string as a sequence of 16-bit UTF-16 char values, using a 
      surrogate pair to represent Unicode astral codepoints. In XPath, strings need to be codepoint-addressible 
      (at least for the purposes of functions such as <code>substring()</code> and <code>translate()</code>), and neither <code>String</code> nor 
      <code>CharSequence</code> meets this requirement. There are also issues concerning comparison across different 
      implementations of the <code>CharSequence</code> interface, plus the fact that many commonly used methods in the 
      standard Java class library require the <code>CharSequence</code> to be converted to a <code>String</code>, which generally 
      involves copying the content. In addition, the <code>CharSequence</code> interface doesn't guarantee immutability. 
      For these reasons, we had already introduced another string representation, the <code>UnicodeString</code>, which 
      we were using in many corners of the code, notably when processing regular expressions.
</para>
    <para>C# has no direct equivalent of <code>CharSequence</code>: that is, an interface which is implemented by the 
      standard String class, but which also allows for other implementations. The interface <code>IEnumerable&lt;Char></code> 
      comes close, but that doesn't allow for direct addressing to get the <emphasis>N</emphasis>th character in a string.
</para>
    <para>So we decided to scrap our extensive use of <code>CharSequence</code> throughout the product, and replace it with 
      our own <code>UnicodeString</code> interface – which allows for direct codepoint addressing, rather than <code>char</code> 
      addressing with surrogate pairs. There is a performance hit in doing this, because there's a lot 
      of conversion between <code>String</code> and <code>UnicodeString</code> when data crosses the boundary between Saxon and 
      third-party software (notably the XML parser, but also library routines such as <code>upperCase()</code> and 
      <code>lowerCase()</code>). However, it's sufficiently small that most users won't notice the difference, and 
      we can mitigate it – for example we have our own UTF-8 Writer used by the Saxon serializer, and 
      it was easy to extend the UTF-8 Writer to accept a <code>UnicodeString</code> as input, bypassing the conversion 
      of <code>UnicodeString</code> to <code>String</code> prior to UTF-8 encoding.
</para>
  </section>
  <section>
    <title>Examples of Converted Code</title>
    <para>To set the scene, it might be useful to provide a couple of examples of converted code, illustrating the
    challenges.</para>
    <para>Here's a rather simple method in Java:</para>
    <programlisting language="java"><![CDATA[@Override
    public AtomicSequence atomize() throws XPathException {
        return tree.getTypedValueOfElement(this);
    }]]></programlisting>
    <para>And here is the C# code that we generate:</para>
    <programlisting language="csharp"><![CDATA[public override net.sf.saxon.om.AtomicSequence atomize() {
    return tree.getTypedValueOfElement(this);
}]]></programlisting>
    <para>Nothing very remarkable there, but it actually requires a fair bit of analysis of the Java code
    to establish that the conversion in this case is fairly trivial. For example:</para>
    <itemizedlist>
      <listitem><para>The class name <code>AtomicSequence</code> has been expanded; this requires analysis
      of the <code>import</code> declarations in the module, and it can't be done without knowing the full
      set of packages and classes available.</para></listitem>
      <listitem><para>The <code>@Override</code> declaration is optional in Java, but <code>optional</code>
      is mandatory in C#; moreover they don't mean quite the same thing, for example when overriding
      methods defined in an interface or abstract class.</para></listitem>
      <listitem><para>The conversion of Java <code>this</code> to C# <code>this</code> works here,
      but there are other contexts where it doesn't work.</para></listitem>
    </itemizedlist>
    <para>Now let's take a more complex example. Consider the following Java code:</para>
    <programlisting language="java"><![CDATA[public Map<String, Sequence> getDefaultOptions()  {
    Map<String, Sequence> result = new HashMap<>();
    for (Map.Entry<String, Sequence> entry : defaultValues.entrySet()) {
        result.put(entry.getKey(), entry.getValue());
    }
    return result;
}]]></programlisting>
    <para>In C# this becomes (with abbreviated namespace qualifiers, for readability):</para>
    <programlisting language="csharp"><![CDATA[public S.C.G.IDictionary<string, n.s.s.o.Sequence> getDefaultOptions() {
    S.C.G.IDictionary<string, n.s.s.o.Sequence> result = 
            new S.C.G.Dictionary<string, n.s.s.o.Sequence>();
    foreach (S.C.G.KeyValuePair<string, n.s.s.o.Sequence> entry in defaultValues) {
        result[entry.Key] = entry.Value;
    }
    return result;
}]]></programlisting>
    <para>There's a lot going on here:</para>
    <itemizedlist>
      <listitem>
        <para>We've replaced the Java <code>Map</code> with a C# <code>Dictionary</code>, and its <code>put()</code>
        method has been replaced with an indexed assignment;</para>
      </listitem>
      <listitem>
        <para>The Java iterable <code>defaultValues.entrySet()</code> has been replaced with the C# enumerable
        <code>defaultValues</code>;</para>
      </listitem>
      <listitem>
        <para>The references to <code>entry.getKey()</code> and <code>entry.getValue()</code>
          have been replaced with property accessors <code>entry.Key</code> and <code>entry.Value</code>.</para>
      </listitem>
      <listitem>
        <para>The replacement of <code>result.put(key, value)</code> by <code>result[key] = value</code>
          is fine in this context, but it needs care, because if the return value of the expression is used,
          the Java code returns the previous value associated with the key, while the C# code returns the new
          value. The rewrite works here only because the expression appears in a context where its result
          is discarded.</para>
      </listitem>
    </itemizedlist>
  </section>
  <section>
    <title>Architecture of the Converter</title>
    
    <para>The overall structure of the transpiler is shown below:</para>
    
    <mediaobject>
      <imageobject>
        <imagedata fileref='architecture.svg' width="100%"/>
      </imageobject>
    </mediaobject>
    
    <para>Let's explain this:</para>
    
    <itemizedlist>
      <listitem>
        <para>On the left, we have 2000+ Java modules.</para>
      </listitem>
      <listitem>
        <para>These are converted to an XML representation by applying the JavaParser, and serializing
        the resulting parse tree as XML.</para>
      </listitem>
      <listitem>
        <para>An XSLT transformation takes all the XML files as input and generates a digest of the
        class and method hierarchy.</para>
      </listitem>
      <listitem>
        <para>A further XSLT transformation enhances the digest by analyzing which methods override each
        other.</para>
      </listitem>
      <listitem>
        <para>Each of the 2000+ XML modules is then converted to C# by applying an XSLT transformation,
        which takes the enhanced digest file as an additional input.</para>
      </listitem>
    </itemizedlist>
    
    <para>The first stage of conversion is to parse each Java module and generate an abstract syntax 
      tree, which can be serialized as XML. For this purpose we use the open-source JavaParser 
      product<footnote><para><uri xl:href="http://javaparser.org">http://javaparser.org</uri></para></footnote>.
</para>
    <para>JavaParser generates the parse tree as a hierarchy of (not very well documented) Java objects. 
      It also includes the capability to serialize this hierarchy as XML. We don't use its out-of-the-box 
      serialization however: we augment it with additional semantic information. JavaParser in fact has 
      two parts (originally developed independently, and still showing evidence of the fact): the parser 
      itself, which is exactly what it says, and the "symbol solver", which is a set of queries that can 
      be executed on the parse tree to obtain additional information. For example, if the raw source code 
      contains the expression <code>new HashMap&lt;>()</code>, this will appear in the raw tree as:
</para>
    <programlisting language="xml"><![CDATA[<value nodeType="ObjectCreationExpr">
    <type nodeType="ClassOrInterfaceType">
       <name nodeType="SimpleName" identifier="HashMap"/>
       <typeArguments/>
    </type>
</value>]]></programlisting>


    <para>But with the aid of the symbol solver, it is straightforward to establish that the name 
      <code>HashMap</code> refers to the class <code>java.util.HashMap</code>, and we output this as an additional attribute 
      on the tree, thus:
</para>
    <programlisting language="xml"><![CDATA[<value nodeType="ObjectCreationExpr">
    <type nodeType="ClassOrInterfaceType" 
          RESOLVED_TYPE="java.util.HashMap">
       <name nodeType="SimpleName" identifier="HashMap"/>
       <typeArguments/>
    </type>
</value>]]></programlisting>
    
    <para>Similarly, the symbol solver is usually able to find the declaration corresponding to a 
      variable reference or method call, and hence to establish the static type of the variable or 
      of the method result. I say usually, because there are cases it gives up on. It struggles, 
      for example, with the types of the arguments to a lambda expression, for example the variable 
      <emphasis>n</emphasis> in
</para>
    <programlisting language="java">search.setPredicate(n -> n.name="John")</programlisting>
    <para>Similarly it has difficulty with static wildcard imports:
</para>
    <programlisting language="java">import static org.w3.dom.Node.*;</programlisting>
    <para>The other problem with the symbol solver is that it can do a lot of things that aren't mentioned 
      in the documentation: we've found some of these by experiment, or by studying the source code. No 
      doubt there are other gems that remain hidden.
</para>
    <para>The result of this process is that for each Java module in the product, we generate a corresponding 
      XML file containing its decorated syntax tree.
</para>
    <para>In principle we could now write an XSLT transformation that serializes this syntax tree using C# syntax. 
      But there's another step first. In some cases we can't generate the C# one file at a time: we need some 
      global information. For example, if a C# method is to be overridden in a subclass, it needs to be 
      flagged with the <code>virtual</code> modifier. Similarly, overriding methods need to be flagged as <code>override</code>. 
      We therefore need to construct a map of the entire class hierarchy, working out which methods are 
      overridden and which are overrides. 
</para>
    <para>So the second phase of processing is to scan the entire collection of XML documents and generate 
      a digest file (itself an XML document, naturally) which acts as an index of classes, interfaces, 
      and methods, and which represents the class hierarchy of the application. Then (our third phase) 
      we do a transformation on the digest file which augments it with decisions about which methods 
      are overriding and which are virtual.
</para>
    <para>Now finally we can perform the XML-to-C# phase, implemented as an XSLT transformation applied 
      to each of the XML documents generated in phase one, but with the digest file available as 
      additional information.
</para>
    <para>The C# is then ready to be compiled and executed.
</para>
  </section>
  <section>
    <title>Difficulties</title>

    <para>In this section we outline some of the features of the Java language where conversion 
      posed particular challenges, and explain briefly how these were tackled.
</para>
    <para>It's worth noting that there are broadly three classes of solution for each of these 
      difficulties:
</para>
    <itemizedlist>
      <listitem>
        <para>Create an automated conversion that handles the Java construct and converts it 
          to equivalent C#. Note that although this is an automatic conversion, it doesn't 
          necessarily have to handle every edge case, in the way that a productised converter 
          might be expected to do. In particular, it doesn't have to handle edge cases that 
          the Saxon code doesn't rely on: for example the converted code doesn't have to handle 
          <code>null</code> as an input in exactly the same way as the original Java, if Saxon never 
          supplies <code>null</code> as the input.
        </para>
      </listitem>
      <listitem>
        <para>Convert with the aid of annotations manually added to the Java code. 
          We'll see examples of some of these annotations later.
        </para>
      </listitem>
      <listitem>
        <para>Eliminate use of the problematic construct from the Java code, replacing it with 
          something that can be more easily converted. A trivial example of this relates to the 
          use of names. Java allows a field and a method in a class to have the same name; C# 
          does not. Simple solution: manually rename fields where necessary so that no Saxon 
          class ever has a field and a method with the same name. (Very often, imposing such 
          a rule actually improves the Java code.)
        </para>
      </listitem>
    </itemizedlist>

    <para>The following sections describe some of the difficulties, in no particular order.
</para>
    <section>
      <title>Dependencies</title>

      <para>Java has a class <code>java.util.HashMap</code> (which Saxon uses extensively). C# does not have 
        a class with this name. It does have a rather similar class <code>System.Dictionary</code>, but 
        there are differences in behavior.
</para>
      <para>Broadly speaking, there are three ways we deal with dependencies:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Rewriting</emphasis>. Here the converter (specifically, the XML-to-C# transformation stylesheet) 
            has logic to rename references to the class <code>java.util.HashMap</code> so they instead refer to 
            <code>System.Collections.Generic.Dictionary</code>, and to convert calls on the methods of <code>java.util.HashMap</code> 
            so they instead call the corresponding methods of <code>System.Dictionary</code>. We've already
            seen an example of this above. Sometimes 
            there is no direct equivalent for a particular method, in which case we instead 
            generate a call on a helper method that emulates the required functionality. 
            (<code>System.Collections.Generic.Dictionary</code>, for example, has no direct equivalent to the <code>get()</code> method 
            on <code>java.util.HashMap</code>, largely because it cannot use <code>null</code> as a return value 
            when the required key is absent.)
    </para>
          <para>The converter uses rewriting for the vast majority of calls on commonly used 
            classes and methods. There's more detail on how this is done below.
    </para>
        </listitem>
        <listitem>
          <para><emphasis>Emulation</emphasis>. Here we implement (in C#) a class that emulates the behaviour of the 
            Java class – or at least, those parts of the behaviour that Saxon relies on. An 
            example where we do this is <code>java.util.Properties</code>, which has no direct equivalent 
            in C#, but which is easily implemented using dictionaries. Saxon doesn't use the 
            complicated methods for importing and exporting <code>Properties</code> objects, so we don't 
            need to emulate those.
    </para>
        </listitem>
        <listitem>
          <para><emphasis>Avoidance</emphasis>. Here we simply eliminate the dependency. For example, the Java 
            product will accept input from either a push (SAX) or pull (StAX) parser. On 
            C# we will only support a single XML parser, the one from Microsoft. This is a 
            pull parser, so we eliminate all the Saxon code that's specific to SAX support. 
            This is non-trivial, of course, because the relevant code is widely scattered 
            around the product. But once found, it's usually easy to get rid of it using 
            preprocessor directives in the Java (<code>//#if CSHARP==false</code>). I should perhaps have 
            mentioned that there's a "phase 0" in our conversion pipeline, which is to apply 
            these preprocessor directives.
    </para>

        </listitem>
      </itemizedlist>

<para>
  In cases where dependencies are handled by rewriting, there are two parts to this. Firstly, we have
  a simple mapping of class names. This includes both system classes and Saxon-specific classes.
  Here are a few of them:
</para>
      <programlisting language="xml"><![CDATA[<xsl:variable name="specialTypes" 
        as="map(xs:string, xs:string)" 
        select="map{
  'boolean':           'bool',
  'java.io.BufferedInputStream': 
                       'System.IO.BufferedStream',
  'java.io.BufferedOutputStream': 
                       'System.IO.BufferedStream',
  'java.io.BufferedReader': 
                       'Saxon.Impl.Helpers.BufferedReader',
  'java.lang.ArithmeticException': 
                       'System.ArithmeticException',
  'java.lang.ArrayIndexOutOfBoundsException': 
                       'System.IndexOutOfRangeException',
  'java.lang.Boolean': 'System.Boolean',
  'java.lang.Byte':    'System.Byte',
      ...
  'java.math.BigDecimal': 
                       'Singulink.Numerics.BigDecimal',
      ...
  'java.util.ArrayList': 
                       'System.Collections.Generic.List',
  'java.util.Collection': 
                       'System.Collections.Generic.ICollection',
  'java.util.Comparator': 
                       'System.Collections.Generic.Comparer',
      ...
  'net.sf.saxon.ma.trie.ImmutableHashTrieMap': 
                       'System.Collections.Immutable.ImmutableDictionary',
  'net.sf.saxon.ma.trie.ImmutableMap': 
                       'System.Collections.Immutable.ImmutableDictionary',
  'net.sf.saxon.ma.trie.ImmutableList': 
                       'System.Collections.Immutable.ImmutableList',
  'net.sf.saxon.ma.trie.TrieKVP': 
                       'System.Collections.Generic.KeyValuePair',
       ...
  'net.sf.saxon.s9api.Message': 
                       'Saxon.Api.Message',
  'net.sf.saxon.s9api.QName': 
                       'Saxon.Api.QName',
  'net.sf.saxon.s9api.SequenceType': 
                       'Saxon.Api.XdmSequenceType',
      ...
}"/>]]></programlisting>
      
      <para>Note that there are cases where we replace system classes with Saxon-supplied classes, and there
      are also cases where we do the reverse: the extract above illustrates that we can replace Saxon's
      immutable map implementation with the standard immutable map in .NET. In the case of <code>BigDecimal</code>,
        we rewrite the code to use a third-party 
        library<footnote><para><uri xl:href="https://github.com/Singulink/Singulink.Numerics.BigDecimal">https://github.com/Singulink/Singulink.Numerics.BigDecimal</uri></para></footnote> 
        with similar functionality to the built-in Java class.</para>
      
      <para>The other part of the rewrite process is to handle method calls. We rely here
      on knowing the target class of the method, and we typically handle the rewrite
      with a template rule like this (long namespace names abbreviated for space reasons: <code>S.N</code> =
        <code>Singulink.Numerics</code>, <code>S.I.H</code> = <code>Saxon.Impl.Helpers</code>)</para>


      <programlisting language="xml"><![CDATA[<xsl:template match="*[@RESOLVED_TYPE = 'java.math.BigDecimal']" 
      priority="20" mode="methods">
  <xsl:sequence select="f:applyFormat(., map{
     'add#1':       '(%scope%+%args%)',
     'subtract#1':  '(%scope%-%args%)',
     'multiply#1':  '(%scope%*%args%)',
     'divide#1':    'S.N.BigDecimal.Divide(%scope%, %args%, 18)',
     'divide#2':    'S.N.BigDecimal.Divide(%scope%, %args%)',
     'divide#3':    'S.N.BigDecimal.Divide(%scope%, %args%)',
     'negate#0':    '-%scope%',
     'mod#1':       'S.I.H.BigDecimalUtils.Mod(%scope%, %args%)',
     'signum#0':    '%scope%.Sign',
     'remainder#1': 'S.I.H.BigDecimalUtils.Remainder(%scope%, %args%)',
     'divideToIntegralValue#1':     
                    'S.I.H.BigDecimalUtils.Idiv(%scope%, %args%)',
     'divideAndRemainder#1':        
                    'S.I.H.BigDecimalUtils.DivideAndRemainder(%scope%, %args%)',
     'valueOf#1':   'Saxon.Impl.Helpers.BigDecimalUtils.ValueOf(%args%)',
     'intValue#0':  '((int)%scope%)',
     'longValue#0': '((long)%scope%)',
     'doubleValue#0':
                    '((double)%scope%)',
     'floatValue#0':'((float)%scope%)',
     'longValueExact#0':            
                    'S.I.H.BigIntegerUtils.LongValueExact(%scope%)',
     'setScale#1':  '%scope%', (:no-op, values are normalized:)
     'setScale#2':  '%scope%', (:no-op, values are normalized:)
     'stripTrailingZeros#0':        
                    '%scope%', (:no-op, values are normalized:)
     'toBigInteger#0':              
                    '((System.Numerics.BigInteger)%scope%)',
     '*':           '%scope%.%Name%(%args%)' 
  })"/>

</xsl:template>]]></programlisting>
      <para>This is a template rule in mode <code>methods</code>, a mode that is only used 
        to process <code>MethodCall</code> expressions, so we don't need to repeat this in the 
        match pattern. This particular rule handles all calls where the target 
        class is <code>java.math.BigDecimal</code>. It delegates the processing to a function 
        <code>f:applyFormat()</code> which is given as input a set of sub-rules supplied as a 
        map in a custom microsyntax. Given the name and arity of the method call, 
        this function looks up the applicable sub-rule, and interprets it: for 
        example <code>value1.add(value2)</code> translates to <code>(value1+value2)</code> (C# allows user-defined 
        overloading of operators such as "+"). Some methods such as <code>mod()</code> are converted 
        into calls on a static helper method (written in C#) in class 
        <code>Saxon.Impl.Helpers.BigDecimalUtils</code>.
</para>
      <para>Most of the product's dependencies have proved easy to tackle using one or 
        more of these mechanisms. We were able to use rewriting more often than I expected – 
        for example it's used to replace the dependency on Java's BigDecimal class with a 
        third-party library, Singulink.Numerics.BigDecimal. It's worth showing the XSLT 
        code that drives this:
      </para>
    </section>
    <section>
      <title>Iterators and Iterables</title>

      <para>There is a close correspondence between the Java interface <code>Iterable</code> and 
        C#'s <code>IEnumerable</code>; and similarly between Java's <code>Iterator</code> and C# <code>IEnumerator</code>. 
        In both cases the interface is closely tied up with the ability to write a 
        "for each" loop. If we're going to be able to translate this Java:
</para>
      <programlisting language="java">for (Attribute att : attributes) {...}</programlisting>
      <para>into this C#:</para>

      <programlisting language="csharp">foreach(Attribute att in attributes) {...}</programlisting>

      <para>then the variable <code>attributes</code>, which is an <code>Iterable</code> in Java, had better become 
        an <code>IEnumerable</code> in C#. We can handle that by rewriting class names; and we can also 
        rewrite the method <code>attributes.iterator()</code> as <code>attributes.GetEnumerable()</code> so that it 
        satisfies the C# interface. What now gets tricky is that Java's <code>Iterator</code> has two 
        methods <code>hasNext()</code> and <code>next()</code> which don't correspond neatly to C# <code>IEnumerator</code>, 
        which has <code>MoveNext()</code> and <code>Current</code>. Specifically, <code>hasNext()</code> is stateless, and can 
        be called any number of times, while <code>MoveNext()</code> is state-changing and can only 
        be called once. However, "sane" code that uses an iterator always makes one call 
        on <code>hasNext()</code> followed by one call on <code>next()</code>, and that sequence translates directly 
        to a call on <code>MoveNext()</code> followed by a call on <code>Current</code>. So the converter assumes 
        that the code will follow this discipline – and if we find code that doesn't, 
        then we have to change it<footnote><para>A benefit of having the parsed Java code in XML format
        is that it's easy to do queries to search for code that needs to be inspected.</para></footnote>.
</para>
    </section>
    <section>
      <title>Inner classes</title>

      <para>Java effectively has three kinds of inner class: named static inner classes, 
        named instance-level inner classes, and anonymous classes. Only the first of 
        these has a direct equivalent in C#.
</para>
      <para>Saxon makes extensive use of all three kinds of inner class. The converter 
        makes a strenuous effort to convert all of them to static named inner classes, 
        but this doesn't always succeed. In some cases it can't succeed, because there 
        are things that static named inner classes aren't allowed to do.
</para>
      <para>Sometimes the conversion can be made to work with the help of hints supplied 
        as Java annotations. For example we might see the following annotation on a method 
        that instantiates an anonymous inner class:
</para>
      <programlisting language="java">@CSharpInnerClass(outer=false, 
        extra={"net.sf.saxon.expr.XPathContext context", 
               "net.sf.saxon.om.Function function"})</programlisting>
      <para>This indicates to the converter that in the generated static inner class, 
        there is no need to pass a reference to the outer <code>this</code> class (because it's not used), 
        but there is a need to pass the values of variables <code>context</code> and <code>function</code> from the outer 
        class to the inner class. (Annotations, like anything else in the Java source code, are 
        parsed by JavaParser and made visible in the syntax tree.)
</para>
    </section>
    <section>
      <title>Overriding, Covariance, Contravariance</title>
      <para>As we've already mentioned, C# requires any method that is overridden to be 
        declared <code>virtual</code>, and any method that overrides another to be declared 
        with the modifier <code>override</code>. 
        We handle this by analyzing the class hierarchy and recording the analysis in the 
        digest XML file, which is available to the stylesheet that generates the C# code.
</para>
      <para>In addition, Java allows an overriding method to have a covariant return type: 
        if <code>Expression.evaluate()</code> returns <code>Sequence</code>, then <code>Arithmetic.evaluate()</code> can return 
        <code>AtomicValue</code>, given that <code>AtomicValue</code> is a subclass of Sequence. C# doesn't allow 
        covariant return types until version 9.0 of the language, and we decided this was a new promised 
        feature that we would be unwise to rely on. Instead:
</para>
      <itemizedlist>
        <listitem>
          <para>when we're analyzing the class hierarchy, we detect any use of covariance, 
            and change the overriding method to use the same return type as its base method;</para>
        </listitem>
        <listitem>
          <para>when we're analyzing the class hierarchy, we detect any use of covariance, 
            and change the overriding method to use the same return type as its base method
            when we find a call to a method that's been overridden with a covariant return type, we 
            insert a cast so the expected type remains as it was.
          </para>
        </listitem>
      </itemizedlist>
      
      <para>Java allows interfaces to define default implementations for methods; C# does not. The
      transpiler handles default method implementations by copying them into each subclass. This
      of course can lead to a lot of code duplication, so we have eliminated some of the cases where
      we were using default methods unnecessarily.</para>

    </section>
    <section>
      <title>Generics</title>

      <para>I've already mentioned that we identified early on that generics would be a 
        problem, and one of the steps we took was to reduce unnecessary and unproductive 
        use of generic types. In fact, we have almost totally eliminated all use of 
        generics in Saxon-defined classes, which was the major problem. That leaves 
        generics in system-defined classes (notably the collection classes such as 
        <code>List&lt;T></code>) which we can't easily manage without.
</para>
      <para>In fact, most uses of these classes translate from Java to C# without 
        trouble. But there are still a few difficulties:
</para>
      <para><emphasis>Diamond Operators</emphasis></para>
      <para>Java allows you to write <code>List&lt;X> list = new ArrayList&lt;>()</code> (referred 
        to as a diamond operator, though it's not technically an operator). In C# it has 
        to be <code>new ArrayList&lt;X>()</code>. So we need to work out what X is – essentially by 
        applying the same type inferencing rules that the Java compiler applies. The way 
        we do this is by recognising common cases: object instantiation on the right-hand 
        side of an assignment, in a return clause, in an argument to a non-polymorphic 
        method, etc. The logic is quite complex, and it catches perhaps 95% of cases. The 
        remainder are handled by changing the Java code: either by introducing a variable, 
        or by adding the type redundantly within the diamond.
</para>
      <para>XSLT template rules really come into their own here. We handle about a dozen 
        patterns where the type of the parameter can be inferred, and each of these is 
        represented by a template rule. As we get smarter or discover more cases, we can 
        simply add more template rules. Here's an example of one of the rules:</para>
      <programlisting language="xml"><![CDATA[<xsl:template match="*[@nodeType='ReturnStmt']
        [ancestor::member[1]/type/@RESOLVED_TYPE]/*">
   <xsl:variable name="type" 
                 select="ancestor::member[1]/type/@RESOLVED_TYPE" 
                 as="xs:string"/>
   <xsl:value-of select="f:extract-type-arguments($type)"/>
</xsl:template>]]></programlisting>
      <para>This rule detects a diamond operator appearing in a return statement (the rule appears
      in a module with default mode <code>diamond</code>, which is only used to process expressions
      that have already been recognised as containing a diamond operator). It finds the ancestor
      method declaration (<code>ancestor::member[1]</code>), determines the declared type of the
      method result, and inserts that into the C# code as the type parameter in place of the
      diamond operator.</para>
      <para><emphasis>Wildcards</emphasis></para>
<para>The Java wildcard constructs <code>&lt;? extends T></code> and <code>&lt;? super T></code> have no direct equivalent 
in C#. The way we handle these depends on where they are used. The default action of the 
converter is just to replace them with <code>&lt;T></code>, which often works. But in class and method 
declarations we generate a C# <code>where</code> clause to constrain the type bounds, so 
</para>
      <programlisting language="java"><![CDATA[public class GroundedValueAsIterable<T extends Item> 
     implements Iterable<T> {...}]]></programlisting>
      <para>becomes</para>

      <programlisting language="csharp"><![CDATA[public class GroundedValueAsIterable<T> : IEnumerable<T> 
     where T : Item {...}]]></programlisting>

      <para>One issue we face is that the default type <code>Object</code> in Java is less all-embracing 
        than the object type in C#: the former does not include primitive types such as int 
        or double, the latter does. This means that where the required type is <code>Object</code>, the 
        supplied value can be null; but this is not so in C#, because primitive types do 
        not allow a null. This permeates the design of collection classes. Often the solution 
        is to constrain the C# class to handle reference types only, using the clause <code>where T : class</code>.
</para>
    </section>
    <section>

      <title>Lambda Expressions and Delegates</title>

      <para>Lambda expressions in Java translate quite easily to lambda expressions 
        in C#: apart from the use of a different arrow symbol, the rules are very similar.
</para>
      <para>I've already mentioned that the JavaParser symbol solver struggles a bit with 
        type inference inside lambda expressions, and we sometimes need to provide a bit 
        of assistance by declaring types explicitly.
</para>
      <para>The main problem, however, is that Java is much more flexible than C# about 
        where lambda expressions are allowed to appear. To take an example, we have a 
        method <code>NodeInfo.iterateAxis(Axis, NodeTest)</code>. On the Java side, 
        <code>NodeTest</code> is a functional interface, 
        which means the caller can either supply a lambda expression such as 
        <code>node -> node.getURI() == null</code>, or they can supply an instance of a class 
        that implements the <code>NodeTest</code> interface, for example 
        <code>new LocalNameTest("foo")</code>. In C# <code>NodeTest</code> must either be defined 
        as a delegate, in which case the caller must supply a lambda expression and not an implementing class, 
        or it can be defined as a regular interface, in which case they can supply an implementing class but 
        not a lambda expression.
</para>
      <para>To solve this, in most cases we've kept it as an interface, but supplied an 
        implementation of the interface that accepts a lambda expression. So if you want 
        to use a lambda expression here, you have to write 
        <code>NodeTestLambda.of(node -> node.getURI() == null)</code>. Which is convoluted, but works.
</para>
    </section>
    <section>
      <title>Exceptions</title>

      <para>The most obvious difference here between Java and C# is that C# does not have 
        checked exceptions. Most of the time, all this means is that we can drop the 
        <code>throws</code> clause from method declarations.
</para>
      <para><code>Try/catch</code> clauses generally translate without trouble. A <code>try</code> clause that 
        declares resources needs a little more care but we hardly use these in Saxon. 
        The syntax for a <code>catch</code> that lists multiple exceptions is a little different, 
        but the conversion rule is straightforward enough.
</para>
      <para>The main problem is deciding on the hierarchy of exception classes. If 
        the Java  code tries to catch <code>NumberFormatException</code>, how should we convert it? 
        What exception will the C# code be throwing in the same situation?
</para>
      <para>To be honest, I think we probably need further work in this area. Although 
        we're passing 95% of test cases already, I think we'll find that quite a few of 
        the remaining 5% are negative tests where correct catching of exceptions plays 
        a role, and we'll need to give this more careful attention.
</para>
    </section>
  </section>
  <section>
    <title>XSLT Considerations</title>

    <para>In this section I'll try to draw out some observations about the XSLT implementation.
</para>
    <para>Like most XSLT code, it has been developed incrementally: rules are added as the 
      need for them is discovered. This is one of the strengths of XSLT as an implementation 
      language for this kind of task: the program can grow very organically, with little need 
      for structural refactoring. At the same time, uncontrolled growth can easily result in a 
      lack of structure. How many modes should there be, and how do we decide? How should 
      the code be split into modules? How should template rule priorities be allocated?
</para>
    <para>Again, like most XSLT applications, it's not just template rules: there are also 
      quite a few functions. And as in other programming languages, the set of functions you 
      end up with, and their internal complexity and external API, can grow rather arbitrarily.
</para>
    <para>It's worth looking a little bit at the nature of the XML we're dealing with. Here's a sample:
</para>
    <programlisting language="xml"><![CDATA[<member nodeType="MethodDeclaration">
 <body nodeType="BlockStmt">
  <statements>
   <statement nodeType="ReturnStmt">
    <expression nodeType="BinaryExpr" 
                operator="PLUS">
     <left nodeType="MethodCallExpr" 
           RETURN="double"
           RESOLVED_TYPE="net.sf.saxon.expr.Expression">
      <name nodeType="SimpleName" identifier="getCost"/>
      <scope nodeType="MethodCallExpr" 
             RETURN="net.sf.saxon.expr.Expression"
             DECLARING_TYPE="net.sf.saxon.expr.BinaryExpression">
        <name nodeType="SimpleName" identifier="getLhsExpression"/>
      </scope>
     </left>
     <right nodeType="BinaryExpr" operator="DIVIDE">
      <left nodeType="MethodCallExpr" RETURN="double"
            RESOLVED_TYPE="net.sf.saxon.expr.Expression">
       <name nodeType="SimpleName" identifier="getCost"/>
        <scope nodeType="MethodCallExpr"
               RETURN="net.sf.saxon.expr.Expression"
               DECLARING_TYPE="net.sf.saxon.expr.BinaryExpression">
         <name nodeType="SimpleName" 
               identifier="getRhsExpression"/>
        </scope>
      </left>
      <right nodeType="IntegerLiteralExpr" 
             value="2"/>
     </right>
    </expression>
   </statement>
  </statements>
 </body>
 <type nodeType="PrimitiveType" 
       type="DOUBLE" 
       RESOLVED_TYPE="double"/>
 <modifiers>
  <modifier nodeType="Modifier" 
            keyword="PUBLIC"/>
 </modifiers>
 <annotations>
  <annotation nodeType="MarkerAnnotationExpr">
   <name nodeType="Name" identifier="Override"/>
  </annotation>
 </annotations>
</member>]]></programlisting>
    <para>This represents the Java code </para>
    <programlisting language="java">@Override
public double getCost() {
    return getLhsExpression().getCost() 
           + getRhsExpression().getCost() / 2;
}</programlisting>
    <para>It's interesting to look at the values used (a) for the element name (e.g. 
      <code>body</code>, <code>left</code>, <code>right</code>, <code>expression</code>, <code>statement</code>), 
      and (b) for the <code>nodeType</code> attribute 
      (e.g. <code>ReturnStmt</code>, <code>BinaryExpr</code>, <code>SimpleName</code>). 
      Generally, the <code>nodeType</code> attribute says 
      what kind of thing the element represents, and the element name indicates what 
      role it plays relative to the parent. (Reminiscent of SGML architectural forms, perhaps?)
</para>
    <para>As an aside, the same dichotomy is present in the design of Saxon's SEF file, 
     which represents a compiled stylesheet, but there we do it the other way around: if an 
     integer literal is used as the right hand side of an addition, the JavaParser 
     format expresses this as <code>&lt;right nodeType="IntegerLiteral"></code>, whereas the SEF 
     format expresses it as <code>&lt;IntegerLiteral role="right"></code>. Of course, neither 
     design is intrinsically better (though the SEF choice works better with XSD validation, 
     since XSD likes the content model of an element to depend only on the element name, 
     not the value of one of its attributes). But the choice does mean that most of our 
     template rules in the transpiler are matching on the <code>nodeType</code> attribute, not on the 
     element name, and this perhaps makes the rules a bit more complicated.
</para>
    <para>Performance hasn't been a concern. I'm pleased to be able to report that 
      of the various phases of processing, the phases written in XSLT are an order 
      of magnitude faster than the phase written in Java; which means that there's 
      no point worrying about speeding the XSLT up. This is despite the fact that 
      (as the above example demonstrates) the XML representation of the code is 
      about 10 times the size of the Java representation.
</para>
    <para>(Actually, the Java code is 29Mb, the XML is 120Mb, and the generated C# 
      is 18Mb. The C# is smaller than the Java mainly because we drop all comments, and also 
      because the Java total includes modules we don't (yet) convert, for example 
      a lot of code dealing with SAX parsers, localisation, and optional extras such 
      as the XQJ API and SQL extension functions).
</para>
    <para>But I would like to think that one reason performance hasn't been a concern 
      is that the code was sensibly written. We've got about 200 template rules here, 
      most of them with quite complicated match patterns, and we wouldn't want to be 
      evaluating every match pattern for every element that's processed.  In fact, a 
      lot of the time we're doing three levels of matching:
</para>
    <itemizedlist>
      <listitem>
        <para>If we find that we're processing a method call (which is rather common), 
          we have a single template rule in the top-level mode that matches 
          <code>*[@nodeType='MethodCallExpr']</code>.
        </para>
      </listitem>
      <listitem>
        <para>This template rule then does <code>&lt;xsl:apply-templates select="." mode="MethodCall"/></code>, 
          which searches for a more specific template rule, but only needs to search the set of 
          rules for handling method calls, because they are all in this mode.
        </para>
        <para>To make the code manageable and maintainable, we put all the template rules for a mode
        in the same module, and use the XSLT 3.0 construct <code>default-mode="M"</code> to reduce
        the risk of accidentally omitting a <code>mode</code> attribute on a template rule
        or <code>xsl:apply-templates</code> instruction.</para>
      </listitem>
      <listitem>
        <para>Most of the template rules for method calls are structured as one rule 
          per target class; as described earlier, this uses a microsyntax for defining 
          the formatting of each possible method, using XSLT maps.
          
          </para>
      </listitem>
    </itemizedlist>
    <para>So it's not a flat set of hundreds of rules; we've used modes (and the microsyntax) 
      to create a hierarchic decision tree. This both improves performance, and keeps the rules 
      simpler and more manageable. It also makes debugging considerably easier: as with any XSLT 
      stylesheet, working out which rules are firing to handle each input element can be difficult, 
      but the splitting of rules into modes certainly helps.
</para>
    <para>(A little known Saxon trick here is the <code>saxon:trace</code> attribute on <code>xsl:mode</code>, which allows 
      tracing of template rule selection on a per-mode basis).
</para>
  </section>
  <section>
    <title>Conclusions</title>

    <para>Firstly, we've confirmed the viability of using XSLT for transformation of abstract 
      syntax trees derived from parsing of complex grammars, on quite a signficant scale. The 
      nature of XSLT as a rule-based pattern matching language makes it ideally suited for such 
      tasks. It's hard to imagine how the pattern matching code would look if it were written 
      in a language such as Java; it would certainly be harder to 
      maintain<footnote><para>While writing the paper, I discovered (without surprise) that 
        transpilation using XSLT has been
        done before: see <uri xl:href="https://www.ijcrt.org/papers/IJCRT2005043.pdf">https://www.ijcrt.org/papers/IJCRT2005043.pdf</uri>. That paper, however,
      gives little detail of how the conversion is done, and appears only to tackle trivial
      code fragments.</para></footnote>.
</para>
    <para>At the same time (and perhaps not quite so relevant to this particular audience, 
      but significant nonetheless) we've demonstrated a pragmatic approach to transpilation. 
      Without writing a tool that can automatically perform 100% conversion of any Java program, 
      we've written a set of rules that works well on the subset of the Java language (and class 
      library) that we're actually using, and more importantly, done so in a way that allows manual
      intervention to handle the parts that can't (cost-effectively) be automated, without 
      sacrificing repeatability - that is, the ability to re-run the conversion every time the 
      Java code changes. And by writing the rules in XSLT, we've created a transpiler that is 
      readily capable of extension to cover features that we chose to leave out first time around.
</para>
    <para>I take satisfaction in the quality of the generated C# code. It's human readable, 
      and it appears to be efficient. This is achieved partly by the policy of not worrying 
      too much about edge cases. By doing our own customised conversion rather than writing 
      a product that has to handle anyone's Java code, we can be pragmatic about exactly how 
      faithfully the C# code needs to be equivalent to the original Java in edge cases.
</para>



  </section>


</article>
